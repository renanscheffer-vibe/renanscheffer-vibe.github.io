<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Timepieces v2</title>
    
    <!-- Design Resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Inter:wght@300;800&family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #000;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Info Button */
        #info-btn {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            font-family: 'Space Mono', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            mix-blend-mode: difference;
            z-index: 20;
        }

        #info-btn:hover {
            background: rgba(255, 255, 255, 1);
            color: black;
            transform: scale(1.1);
        }

        /* Modal Overlay */
        #modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(5px);
            z-index: 30;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Modal Content */
        #modal-content {
            background: #111;
            border: 1px solid #333;
            padding: 40px;
            width: 90%;
            max-width: 400px;
            color: #FFF;
            font-family: 'Inter', sans-serif;
            text-align: center;
            position: relative;
            transform: translateY(20px);
            transition: transform 0.3s ease;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        #modal-overlay.active #modal-content {
            transform: translateY(0);
        }

        #modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1.5rem;
        }

        #modal-close:hover { color: #FFF; }

        .modal-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            margin-top: 20px;
        }

        .modal-val {
            font-family: 'Syne', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .shortcuts {
            margin-top: 40px;
            border-top: 1px solid #333;
            padding-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .key-row {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .key-badge {
            background: #333;
            color: #FFF;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            display: inline-block;
            align-self: center;
            border: 1px solid #444;
        }
        
        /* Grain overlay for texture */
        #grain {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.05;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>

    <div id="grain"></div>
    <canvas id="canvas"></canvas>
    
    <!-- Info Button -->
    <button id="info-btn" onclick="app.toggleModal()">i</button>

    <!-- Modal -->
    <div id="modal-overlay" onclick="app.toggleModal()">
        <div id="modal-content" onclick="event.stopPropagation()">
            <button id="modal-close" onclick="app.toggleModal()">&times;</button>
            
            <h2 style="margin: 0 0 30px 0; font-family: 'Playfair Display'; font-style: italic;">Current Configuration</h2>

            <div class="modal-label">Visual Model</div>
            <div class="modal-val" id="m-model">Loading...</div>

            <div class="modal-label">Color Palette</div>
            <div class="modal-val" id="m-palette">Loading...</div>

            <div class="shortcuts">
                <div class="key-row">
                    <span class="key-badge">R</span>
                    <span class="modal-label" style="margin: 0;">New Clock</span>
                </div>
                <div class="key-row">
                    <span class="key-badge">C</span>
                    <span class="modal-label" style="margin: 0;">New Colors</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * GENERATIVE CLOCK ENGINE
         * -----------------------
         * Handles the orchestration of distinct visual styles, time calculations,
         * and the animation loop.
         */

        const PI2 = Math.PI * 2;

        // --- UTILITIES ---

        const Random = {
            float: (min, max) => Math.random() * (max - min) + min,
            int: (min, max) => Math.floor(Math.random() * (max - min + 1) + min),
            pick: (arr) => arr[Math.floor(Math.random() * arr.length)],
            bool: () => Math.random() > 0.5,
            shuffle: (arr) => arr.sort(() => Math.random() - 0.5)
        };

        const Color = {
            hexToRgb: (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },
            getLuminance: (hex) => {
                const rgb = Color.hexToRgb(hex);
                if (!rgb) return 0;
                return (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b);
            },
            getContrastColor: (hex) => {
                const lum = Color.getLuminance(hex);
                return lum > 128 ? '#000000' : '#FFFFFF';
            },
            getContrastDiff: (hex1, hex2) => {
                return Math.abs(Color.getLuminance(hex1) - Color.getLuminance(hex2));
            },
            // Helper to darken a hex color for 3D shading
            shade: (hex, percent) => {
                let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
                return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
            }
        };

        const Easing = {
            easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
            elastic: (x) => {
                const c4 = (2 * Math.PI) / 3;
                return x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
            },
            smoothStep: (x) => x * x * (3 - 2 * x),
            easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2
        };

        const toRoman = (num) => {
            if (num === 0) return ""; 
            const lookup = {XII:12,XI:11,X:10,IX:9,VIII:8,VII:7,VI:6,V:5,IV:4,III:3,II:2,I:1};
            let roman = '';
            for (let i in lookup) {
                while (num >= lookup[i]) {
                    roman += i;
                    num -= lookup[i];
                }
            }
            return roman;
        };

        // --- PALETTES ---
        
        const PALETTES = [
            { name: "Bauhaus", bg: "#F0F0F0", colors: ["#D02020", "#2040D0", "#E0B020", "#101010"] },
            { name: "Mid-Century", bg: "#F4F1EA", colors: ["#E76F51", "#264653", "#2A9D8F", "#E9C46A"] },
            { name: "Swiss Print", bg: "#FFFFFF", colors: ["#000000", "#FF3300"] },
            { name: "Deep Sea", bg: "#0A192F", colors: ["#64FFDA", "#112240", "#233554", "#8892B0"] },
            { name: "Forest", bg: "#1A2F1A", colors: ["#D4E157", "#AED581", "#81C784", "#4CAF50"] },
            { name: "Monochrome", bg: "#111111", colors: ["#EEEEEE", "#888888", "#444444"] },
            { name: "Solarized", bg: "#002b36", colors: ["#b58900", "#cb4b16", "#dc322f", "#2aa198"] },
            { name: "Cotton Candy", bg: "#FFEFFA", colors: ["#FF9AA2", "#FFB7B2", "#FFDAC1", "#E2F0CB", "#B5EAD7"] },
            { name: "Memphis 80s", bg: "#FFF4E0", colors: ["#FF5E78", "#88D8B0", "#FFCC5C", "#96CEB4"] },
            { name: "Cyberpunk", bg: "#050505", colors: ["#00ff00", "#ff0099", "#00ccff", "#ffff00"] }
        ];

        // --- RENDERERS ---

        /**
         * STYLE 1: THE CONSTRUCTIVIST
         */
        class ConstructivistClock {
            constructor(ctx, width, height, palette) {
                this.name = "Neo-Constructivist";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                this.cols = Random.int(3, 6);
                this.rows = Random.int(3, 6);
                this.cellW = this.w / this.cols;
                this.cellH = this.h / this.rows;
                
                this.staticShapes = [];
                for(let i=0; i<8; i++) {
                    this.staticShapes.push({
                        c: Random.int(0, this.cols-1),
                        r: Random.int(0, this.rows-1),
                        type: Random.pick(['rect', 'circle', 'line']),
                        color: Random.pick(this.colors)
                    });
                }
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms / 1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                this.ctx.strokeStyle = this.colors[this.colors.length-1];
                this.ctx.globalAlpha = 0.1;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for(let x=0; x<=this.w; x+=this.cellW) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.h); }
                for(let y=0; y<=this.h; y+=this.cellH) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.w,y); }
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;

                this.staticShapes.forEach(shape => {
                    this.ctx.fillStyle = shape.color;
                    this.ctx.strokeStyle = shape.color;
                    const cx = shape.c * this.cellW + this.cellW/2;
                    const cy = shape.r * this.cellH + this.cellH/2;
                    if(shape.type === 'rect') {
                        this.ctx.fillRect(shape.c * this.cellW + 10, shape.r * this.cellH + 10, this.cellW-20, this.cellH-20);
                    } else if (shape.type === 'circle') {
                        this.ctx.beginPath();
                        this.ctx.arc(cx, cy, Math.min(this.cellW, this.cellH)/3, 0, PI2);
                        this.ctx.fill();
                    }
                });

                const hX = (this.cols - 2) * this.cellW + this.cellW/2;
                const hY = 1 * this.cellH + this.cellH/2;
                const hRad = Math.min(this.cellW, this.cellH) * 0.4;
                
                this.ctx.beginPath();
                this.ctx.arc(hX, hY, hRad, 0, PI2);
                this.ctx.fillStyle = this.colors[0]; 
                this.ctx.fill();
                
                this.ctx.fillStyle = this.bg;
                this.ctx.beginPath();
                this.ctx.moveTo(hX, hY);
                this.ctx.arc(hX, hY, hRad+1, -Math.PI/2, (-Math.PI/2) + ((h % 12) / 12) * PI2);
                this.ctx.lineTo(hX, hY);
                this.ctx.fill();

                const mRatio = m / 60;
                this.ctx.fillStyle = this.colors[1] || this.colors[0];
                this.ctx.fillRect(0, this.h - this.cellH, this.w * mRatio, this.cellH);

                const sCellX = 1;
                const sCellY = 2;
                const sBoxX = sCellX * this.cellW;
                const sBoxY = sCellY * this.cellH;
                const bounce = Math.abs(Math.sin(smoothS * Math.PI)); 
                
                this.ctx.fillStyle = this.colors[2] || this.colors[0];
                this.ctx.beginPath();
                this.ctx.arc(sBoxX + this.cellW/2, sBoxY + this.cellH - (bounce * (this.cellH * 0.8)) - 20, 15, 0, PI2);
                this.ctx.fill();
                
                this.ctx.fillStyle = this.textColor;
                this.ctx.font = `bold ${this.cellH * 0.2}px 'Inter'`;
                this.ctx.textAlign = "right";
                this.ctx.fillText(`${h12.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')} ${ampm}`, this.w - 20, 50);
            }
        }

        /**
         * STYLE 2: THE KINETIC
         */
        class KineticClock {
            constructor(ctx, width, height, palette) {
                this.name = "Kinetic Typography";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                this.font = Random.pick(['Syne', 'Inter']);
                this.layout = Random.pick(['stack', 'row']);
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const hStr = h12.toString().padStart(2, '0');
                const mStr = m.toString().padStart(2, '0');
                const sStr = s.toString().padStart(2, '0');

                this.ctx.fillStyle = this.colors[0];
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                
                if (this.layout === 'stack') {
                    const fontSize = this.h * 0.35;
                    this.ctx.font = `800 ${fontSize}px '${this.font}'`;
                    
                    const beat = Easing.easeOutExpo(ms/1000); 
                    const xOffset = (beat * 10) - 5; 

                    this.ctx.fillText(hStr, this.w/2 + xOffset, this.h * 0.25);
                    this.ctx.fillStyle = this.colors[1] || this.colors[0];
                    this.ctx.fillText(mStr, this.w/2 - xOffset, this.h * 0.55);
                    this.ctx.fillStyle = this.colors[2] || this.colors[0];
                    this.ctx.font = `800 ${fontSize * 0.5}px '${this.font}'`;
                    this.ctx.fillText(sStr, this.w/2, this.h * 0.85);

                    this.ctx.fillStyle = this.textColor;
                    this.ctx.font = `800 ${fontSize * 0.15}px '${this.font}'`;
                    this.ctx.fillText(ampm, this.w/2, this.h * 0.95);
                } else {
                    const fontSize = this.w * 0.25;
                    this.ctx.font = `800 ${fontSize}px '${this.font}'`;
                    const slide = Easing.elastic(ms/1000);
                    const cellH = fontSize * 1.2;
                    
                    this.ctx.save();
                    this.ctx.translate(this.w/2, this.h/2);
                    this.ctx.textAlign = "right";
                    this.ctx.fillText(hStr + ":", -fontSize * 0.5, 0);
                    this.ctx.textAlign = "center";
                    this.ctx.fillText(mStr + ":", 0, 0);
                    
                    this.ctx.textAlign = "left";
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.rect(fontSize*0.5, -cellH/2, fontSize*1.5, cellH);
                    this.ctx.clip(); 
                    
                    const yPos = slide * cellH;
                    this.ctx.fillStyle = this.colors[1] || this.colors[0];
                    this.ctx.fillText(sStr, fontSize*0.5 + 20, 0 + (1-slide) * 50); 
                    this.ctx.restore();
                    
                    this.ctx.fillStyle = this.textColor;
                    this.ctx.font = `800 ${fontSize * 0.2}px '${this.font}'`;
                    this.ctx.fillText(ampm, 0, fontSize * 0.7);
                    this.ctx.restore();
                }
            }
        }

        /**
         * STYLE 3: THE CELESTIAL
         */
        class CelestialClock {
            constructor(ctx, width, height, palette) {
                this.name = "Planetary Orbit";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                this.zoom = Random.float(0.8, 1.2);
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms / 1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                const cx = this.w / 2;
                const cy = this.h / 2;
                const minDim = Math.min(this.w, this.h);
                
                if (Math.random() > 0.5) { 
                    this.ctx.fillStyle = this.colors[0];
                    const starX = Random.int(0, this.w);
                    const starY = Random.int(0, this.h);
                    this.ctx.fillRect(starX, starY, 2, 2);
                }

                this.ctx.shadowBlur = 40;
                this.ctx.shadowColor = this.colors[3] || this.colors[0];
                this.ctx.fillStyle = this.colors[3] || this.colors[0];
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, minDim * 0.08, 0, PI2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;

                this.ctx.strokeStyle = this.textColor;
                this.ctx.lineWidth = 1;
                this.ctx.globalAlpha = 0.3;

                const hRad = minDim * 0.20 * this.zoom;
                const mRad = minDim * 0.35 * this.zoom;
                const sRad = minDim * 0.45 * this.zoom;

                this.ctx.beginPath(); this.ctx.arc(cx, cy, hRad, 0, PI2); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.arc(cx, cy, mRad, 0, PI2); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.arc(cx, cy, sRad, 0, PI2); this.ctx.stroke();

                this.ctx.globalAlpha = 1;

                const hAngle = ((h % 12) / 12) * PI2 + (m/60 * PI2/12) - Math.PI/2;
                const mAngle = (m / 60) * PI2 + (s/60 * PI2/60) - Math.PI/2;
                const sAngle = (smoothS / 60) * PI2 - Math.PI/2;

                this.ctx.fillStyle = this.colors[0];
                this.ctx.beginPath();
                this.ctx.arc(cx + Math.cos(hAngle)*hRad, cy + Math.sin(hAngle)*hRad, 12, 0, PI2);
                this.ctx.fill();

                this.ctx.fillStyle = this.colors[1] || this.colors[0];
                this.ctx.beginPath();
                this.ctx.arc(cx + Math.cos(mAngle)*mRad, cy + Math.sin(mAngle)*mRad, 8, 0, PI2);
                this.ctx.fill();

                this.ctx.fillStyle = this.colors[2] || this.colors[1];
                this.ctx.beginPath();
                this.ctx.arc(cx + Math.cos(sAngle)*sRad, cy + Math.sin(sAngle)*sRad, 4, 0, PI2);
                this.ctx.fill();

                this.ctx.font = `14px 'Space Mono'`;
                this.ctx.fillStyle = this.textColor;
                this.ctx.textAlign = "center";
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')} ${ampm}`, cx, cy + minDim * 0.08 + 30);
            }
        }

        /**
         * STYLE 4: THE DE STIJL
         */
        class DeStijlClock {
            constructor(ctx, width, height, palette) {
                this.name = "Neo-Plasticism Grid";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                this.borderW = 8;
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const c1 = this.colors[0];
                const c2 = this.colors[1] || c1;
                const c3 = this.colors[2] || c1;

                const splitX = (this.w * 0.3) + (this.w * 0.4) * (m / 60); 
                const splitY = (this.h * 0.2) + (this.h * 0.6) * (smoothS / 60);

                const topLeftColor = (h % 2 === 0) ? c1 : this.bg;

                this.ctx.fillStyle = topLeftColor;
                this.ctx.fillRect(0, 0, splitX, splitY);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(splitX, 0, this.w - splitX, splitY);

                this.ctx.fillStyle = c2;
                this.ctx.fillRect(0, splitY, splitX, this.h - splitY);

                this.ctx.fillStyle = c3;
                if(s > 30) this.ctx.fillRect(splitX, splitY, this.w - splitX, this.h - splitY);

                this.ctx.strokeStyle = this.textColor;
                this.ctx.lineWidth = this.borderW;
                
                this.ctx.beginPath();
                this.ctx.moveTo(splitX, 0);
                this.ctx.lineTo(splitX, this.h);
                this.ctx.moveTo(0, splitY);
                this.ctx.lineTo(this.w, splitY);
                this.ctx.stroke();
                this.ctx.strokeRect(0, 0, this.w, this.h);

                this.ctx.fillStyle = Color.getContrastColor(topLeftColor);
                
                this.ctx.font = "bold 60px 'Inter'";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "top";
                this.ctx.fillText(`${h12} ${ampm}`, 20, 20);
                
                this.ctx.font = "bold 30px 'Inter'";
                this.ctx.textAlign = "right";
                this.ctx.textBaseline = "bottom";
                this.ctx.fillText(m.toString().padStart(2,'0'), splitX - 20, splitY - 20);
            }
        }

        /**
         * STYLE 5: THE SLIT-SCAN
         */
        class SlitScanClock {
            constructor(ctx, width, height, palette) {
                this.name = "Slit-Scan Distortion";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                this.buffer = document.createElement('canvas');
                this.buffer.width = width;
                this.buffer.height = height;
                this.bCtx = this.buffer.getContext('2d');
                
                this.slices = [];
                const sliceCount = 30;
                const sliceH = height / sliceCount;
                for(let i=0; i<sliceCount; i++) {
                    this.slices.push({
                        y: i * sliceH,
                        h: sliceH,
                        offset: 0,
                        speed: Random.float(0.5, 2.0),
                        phase: Random.float(0, PI2)
                    });
                }
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);

                this.bCtx.fillStyle = this.bg;
                this.bCtx.fillRect(0, 0, this.w, this.h);
                
                this.bCtx.textAlign = "center";
                this.bCtx.textBaseline = "middle";
                this.bCtx.fillStyle = this.colors[0];
                
                this.bCtx.font = "900 20vw 'Syne'";
                this.bCtx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, this.w/2, this.h/2);
                
                this.bCtx.font = "700 5vw 'Space Mono'";
                this.bCtx.fillStyle = this.colors[1] || this.textColor;
                this.bCtx.fillText(s.toString().padStart(2,'0'), this.w/2, this.h/2 + (this.w * 0.15));

                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                this.slices.forEach((slice, i) => {
                    const waveY = (smoothS * 2) + (i * 0.2); 
                    const shift = Math.sin(waveY) * (this.w * 0.05); 
                    
                    const snap = Easing.easeOutExpo(ms/1000);
                    const glitch = (1-snap) * (Math.random() * 50 - 25);

                    const finalX = shift + glitch;

                    this.ctx.drawImage(
                        this.buffer, 
                        0, slice.y, this.w, slice.h, 
                        finalX, slice.y, this.w, slice.h
                    );
                    
                    if(finalX > 0) {
                         this.ctx.drawImage(this.buffer, 0, slice.y, this.w, slice.h, finalX - this.w, slice.y, this.w, slice.h);
                    } else if (finalX < 0) {
                         this.ctx.drawImage(this.buffer, 0, slice.y, this.w, slice.h, finalX + this.w, slice.y, this.w, slice.h);
                    }
                });
                
                this.ctx.fillStyle = this.textColor;
                this.ctx.font = "14px 'Space Mono'";
                this.ctx.textAlign = "right";
                this.ctx.fillText("SIGNAL_LOSS: " + (ms/10).toFixed(0) + "%", this.w - 20, 30);
            }
        }

        /**
         * STYLE 6: THE SWARM
         */
        class SwarmClock {
            constructor(ctx, width, height, palette) {
                this.name = "Bio-Digital Swarm";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                this.digitMap = {
                    '0': [1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1],
                    '1': [0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0],
                    '2': [1,1,1, 0,0,1, 1,1,1, 1,0,0, 1,1,1],
                    '3': [1,1,1, 0,0,1, 1,1,1, 0,0,1, 1,1,1],
                    '4': [1,0,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1],
                    '5': [1,1,1, 1,0,0, 1,1,1, 0,0,1, 1,1,1],
                    '6': [1,1,1, 1,0,0, 1,1,1, 1,0,1, 1,1,1],
                    '7': [1,1,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1],
                    '8': [1,1,1, 1,0,1, 1,1,1, 1,0,1, 1,1,1],
                    '9': [1,1,1, 1,0,1, 1,1,1, 0,0,1, 1,1,1],
                    ':': [0,0,0, 0,1,0, 0,0,0, 0,1,0, 0,0,0]
                };

                this.particles = [];
                const pCount = 300;
                for(let i=0; i<pCount; i++) {
                    this.particles.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        vx: Random.float(-2, 2),
                        vy: Random.float(-2, 2),
                        color: Random.pick(this.colors),
                        targetX: null,
                        targetY: null
                    });
                }
            }

            getGridPoints(str, cx, cy, scale) {
                const points = [];
                let offsetX = -(str.length * 4 * scale) / 2;
                
                for(let i=0; i<str.length; i++) {
                    const char = str[i];
                    const map = this.digitMap[char];
                    if(!map) continue;

                    for(let r=0; r<5; r++) {
                        for(let c=0; c<3; c++) {
                            if(map[r*3+c] === 1) {
                                points.push({
                                    x: cx + offsetX + (c * scale),
                                    y: cy + (r * scale) - (2.5 * scale)
                                });
                            }
                        }
                    }
                    offsetX += 4 * scale;
                }
                return points;
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const timeStr = `${h12}:${m.toString().padStart(2,'0')}`;
                const scale = Math.min(this.w, this.h) / 20;
                
                const targets = this.getGridPoints(timeStr, this.w/2, this.h/2, scale);

                this.particles.forEach((p, i) => {
                    const target = targets[i % targets.length];
                    
                    if(target) {
                        const dx = target.x - p.x;
                        const dy = target.y - p.y;
                        p.vx += dx * 0.005;
                        p.vy += dy * 0.005;
                        p.vx *= 0.90; 
                        p.vy *= 0.90;
                    } else {
                        if(p.x < 0 || p.x > this.w) p.vx *= -1;
                        if(p.y < 0 || p.y > this.h) p.vy *= -1;
                    }

                    p.x += p.vx;
                    p.y += p.vy;
                    p.x += Math.sin(ms * 0.01 + i) * 0.5;

                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, scale * 0.3, 0, PI2);
                    this.ctx.fill();
                });
                
                this.ctx.fillStyle = this.textColor;
                this.ctx.fillRect(0, this.h - 10, this.w * (s/60), 10);
            }
        }

        /**
         * STYLE 7: THE ECHO
         */
        class EchoClock {
            constructor(ctx, width, height, palette) {
                this.name = "Temporal Echo";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                
                this.colors = palette.colors.filter(c => Color.getLuminance(c) > 60);
                
                if (this.colors.length < 2) {
                     this.colors = ["#FF00FF", "#00FFFF", "#FFFF00", "#FF3300", "#00FF66"];
                }
                
                const baseRgb = Color.hexToRgb(this.colors[0]);
                if (baseRgb) {
                    const darken = 0.15;
                    this.bg = `rgb(${Math.floor(baseRgb.r * darken)}, ${Math.floor(baseRgb.g * darken)}, ${Math.floor(baseRgb.b * darken)})`;
                } else {
                    this.bg = "#080808"; 
                }

                this.textColor = "#FFFFFF"; 
                this.history = []; 
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const cx = this.w / 2;
                const cy = this.h / 2;

                const layers = 15;
                
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = "800 15vw 'Inter'";

                for(let i = layers; i >= 0; i--) {
                    const depth = i / layers; 
                    
                    const scale = 1 - (depth * 0.9); 
                    const alpha = 1 - depth;
                    const rotation = depth * Math.sin(smoothS * 0.5) * 0.5;
                    
                    this.ctx.save();
                    this.ctx.translate(cx, cy);
                    this.ctx.scale(scale, scale);
                    this.ctx.rotate(rotation);
                    
                    const colorIndex = i % this.colors.length;
                    this.ctx.fillStyle = this.colors[colorIndex];
                    this.ctx.globalAlpha = alpha;
                    
                    const str = `${h12}:${m.toString().padStart(2,'0')}`;
                    
                    if (i === 0) {
                        this.ctx.shadowBlur = 40;
                        this.ctx.shadowColor = this.colors[0]; 
                        this.ctx.fillStyle = this.textColor; 
                        this.ctx.fillText(str, 0, 0);
                        
                        this.ctx.font = "4vw 'Inter'";
                        this.ctx.fillText(s.toString().padStart(2,'0'), 0, 100);
                    } else {
                        this.ctx.strokeStyle = this.colors[colorIndex];
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(str, 0, 0);
                    }

                    this.ctx.restore();
                }
            }
        }

        /**
         * STYLE 8: THE VITRUVIAN
         */
        class VitruvianClock {
            constructor(ctx, width, height, palette) {
                this.name = "Vitruvian Draft";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                this.noise = [];
                for(let i=0; i<100; i++) this.noise.push(Math.random());
            }

            sketchCircle(x, y, r, color) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for(let i=0; i<3; i++) {
                    const offset = (this.noise[i] * 2) - 1; 
                    this.ctx.arc(x, y, r + offset, 0, PI2);
                }
                this.ctx.stroke();
            }

            sketchLine(x1, y1, x2, y2, color) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                const angle = Math.atan2(y2-y1, x2-x1);
                this.ctx.lineTo(x2 + Math.cos(angle)*10, y2 + Math.sin(angle)*10);
                this.ctx.stroke();
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const cx = this.w / 2;
                const cy = this.h / 2;
                const radius = Math.min(this.w, this.h) * 0.35;

                this.ctx.globalAlpha = 0.6;
                this.sketchCircle(cx, cy, radius, this.textColor);
                this.sketchCircle(cx, cy, radius * 0.7, this.colors[0]); 
                this.sketchCircle(cx, cy, radius * 0.4, this.colors[1] || this.textColor); 
                this.ctx.globalAlpha = 1.0;

                this.ctx.strokeStyle = this.textColor;
                this.ctx.globalAlpha = 0.15;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0); this.ctx.lineTo(this.w, this.h);
                this.ctx.moveTo(this.w, 0); this.ctx.lineTo(0, this.h);
                this.ctx.moveTo(cx, 0); this.ctx.lineTo(cx, this.h);
                this.ctx.moveTo(0, cy); this.ctx.lineTo(this.w, cy);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1.0;

                this.ctx.font = "italic 40px 'Playfair Display'";
                this.ctx.fillStyle = this.textColor;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";

                [12, 3, 6, 9].forEach(num => {
                    const angle = (num / 12) * PI2 - Math.PI/2;
                    const dist = radius + 40;
                    const tx = cx + Math.cos(angle) * dist;
                    const ty = cy + Math.sin(angle) * dist;
                    this.ctx.fillText(num.toString(), tx, ty);
                });

                const hAngle = ((h % 12) + m/60) / 12 * PI2 - Math.PI/2;
                const hLen = radius * 0.5;
                const hX = cx + Math.cos(hAngle) * hLen;
                const hY = cy + Math.sin(hAngle) * hLen;
                
                this.sketchLine(cx, cy, hX, hY, this.colors[0]);
                this.ctx.fillStyle = this.colors[0];
                this.ctx.beginPath(); this.ctx.arc(hX, hY, 4, 0, PI2); this.ctx.fill();

                const mAngle = (m + s/60) / 60 * PI2 - Math.PI/2;
                const mLen = radius * 0.8;
                const mX = cx + Math.cos(mAngle) * mLen;
                const mY = cy + Math.sin(mAngle) * mLen;
                
                this.sketchLine(cx, cy, mX, mY, this.colors[1] || this.textColor);
                this.ctx.fillStyle = this.colors[1] || this.textColor;
                this.ctx.beginPath(); this.ctx.arc(mX, mY, 3, 0, PI2); this.ctx.fill();

                const sAngle = smoothS / 60 * PI2 - Math.PI/2;
                const sOrbitR = radius * 0.4; 
                const sX = cx + Math.cos(sAngle) * sOrbitR;
                const sY = cy + Math.sin(sAngle) * sOrbitR;

                this.ctx.fillStyle = this.colors[2] || this.colors[0];
                this.ctx.beginPath();
                this.ctx.arc(sX, sY, 6, 0, PI2);
                this.ctx.fill();
                this.ctx.strokeStyle = this.colors[2] || this.colors[0];
                this.ctx.globalAlpha = 0.3;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, sOrbitR, sAngle - 0.5, sAngle);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1.0;

                this.ctx.font = "italic 16px 'Playfair Display'";
                this.ctx.fillStyle = this.textColor;
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')} ${ampm}`, cx, cy + radius + 80);
            }
        }

        /**
         * STYLE 9: THE ROMAN DIAL
         */
        class RomanDialClock {
            constructor(ctx, width, height, palette) {
                this.name = "Luxury Automatic";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);

                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const cx = this.w / 2;
                const cy = this.h / 2;
                const radius = Math.min(this.w, this.h) * 0.35;

                this.ctx.beginPath();
                this.ctx.arc(cx, cy, radius, 0, PI2);
                this.ctx.strokeStyle = this.textColor;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                this.ctx.font = "400 24px 'Playfair Display'";
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.fillStyle = this.textColor;

                for(let i=1; i<=12; i++) {
                    const angle = (i / 12) * PI2 - Math.PI/2;
                    const rNum = radius * 0.85;
                    const x = cx + Math.cos(angle) * rNum;
                    const y = cy + Math.sin(angle) * rNum;
                    this.ctx.fillText(toRoman(i), x, y);
                }

                const hAngle = ((h % 12) + m/60) / 12 * PI2 - Math.PI/2;
                const mAngle = (m + s/60) / 60 * PI2 - Math.PI/2;
                const sAngle = smoothS / 60 * PI2 - Math.PI/2;

                this.ctx.strokeStyle = this.colors[0];
                this.ctx.lineWidth = 6;
                this.ctx.lineCap = "round";
                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx + Math.cos(hAngle) * (radius * 0.5), cy + Math.sin(hAngle) * (radius * 0.5));
                this.ctx.stroke();

                this.ctx.strokeStyle = this.colors[1] || this.textColor;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx + Math.cos(mAngle) * (radius * 0.7), cy + Math.sin(mAngle) * (radius * 0.7));
                this.ctx.stroke();

                this.ctx.strokeStyle = this.colors[2] || "red";
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx + Math.cos(sAngle) * (radius * 0.8), cy + Math.sin(sAngle) * (radius * 0.8));
                this.ctx.stroke();
                
                this.ctx.fillStyle = this.textColor;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, 5, 0, PI2);
                this.ctx.fill();
            }
        }

        /**
         * STYLE 10: THE AURORA
         */
        class AuroraClock {
            constructor(ctx, width, height, palette) {
                this.name = "Ambient Aurora";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                this.blobs = [];
                for(let i=0; i<4; i++) {
                    this.blobs.push({
                        x: Random.int(0, width),
                        y: Random.int(0, height),
                        r: Random.int(width * 0.3, width * 0.6),
                        c: this.colors[i % this.colors.length],
                        vx: Random.float(-0.5, 0.5),
                        vy: Random.float(-0.5, 0.5),
                        phase: Random.float(0, PI2)
                    });
                }
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);

                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                this.ctx.filter = 'blur(80px)'; 
                this.ctx.globalAlpha = 0.6;
                
                this.blobs.forEach(b => {
                    b.x += b.vx + Math.sin(smoothS * 0.5 + b.phase) * 0.5;
                    b.y += b.vy + Math.cos(smoothS * 0.5 + b.phase) * 0.5;
                    
                    if(b.x < -b.r) b.x = this.w + b.r;
                    if(b.x > this.w + b.r) b.x = -b.r;
                    if(b.y < -b.r) b.y = this.h + b.r;
                    if(b.y > this.h + b.r) b.y = -b.r;

                    this.ctx.fillStyle = b.c;
                    this.ctx.beginPath();
                    this.ctx.arc(b.x, b.y, b.r, 0, PI2);
                    this.ctx.fill();
                });

                this.ctx.filter = 'none';
                this.ctx.globalAlpha = 1.0;

                const cx = this.w / 2;
                const cy = this.h / 2;
                
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.fillStyle = this.textColor;
                
                this.ctx.font = "200 12vw 'Inter'"; 
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = "rgba(0,0,0,0.2)";
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, cx, cy);
                
                this.ctx.font = "300 3vw 'Inter'";
                this.ctx.fillText(`${s.toString().padStart(2,'0')} ${ampm}`, cx, cy + (this.w * 0.1));
                this.ctx.shadowBlur = 0;
            }
        }

        /**
         * STYLE 11: THE FREQUENCY
         */
        class FrequencyClock {
            constructor(ctx, width, height, palette) {
                this.name = "Data Frequency";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                this.waves = [];
                const lines = 20;
                for(let i=0; i<lines; i++) {
                    this.waves.push({
                        offset: i * (height/lines),
                        speed: Random.float(0.5, 2.0),
                        amp: Random.float(20, 100),
                        color: this.colors[i % this.colors.length]
                    });
                }
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);

                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                this.ctx.lineWidth = 2;
                this.waves.forEach((wave, i) => {
                    this.ctx.strokeStyle = wave.color;
                    this.ctx.beginPath();
                    
                    for(let x = 0; x <= this.w; x+=10) {
                        const y = wave.offset + 
                                  Math.sin(x * 0.01 + smoothS * wave.speed + i) * wave.amp + 
                                  Math.cos(x * 0.02 - smoothS) * 20;
                        
                        if(x===0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                });

                const cx = this.w / 2;
                const cy = this.h / 2;

                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(cx - 150, cy - 60, 300, 120);
                this.ctx.strokeStyle = this.textColor;
                this.ctx.lineWidth = 4;
                this.ctx.strokeRect(cx - 150, cy - 60, 300, 120);

                this.ctx.fillStyle = this.textColor;
                this.ctx.font = "700 60px 'Space Mono'";
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, cx, cy);
                
                this.ctx.font = "400 16px 'Space Mono'";
                this.ctx.fillText(`SEC.${s.toString().padStart(2,'0')} // ${ampm}`, cx, cy + 40);
            }
        }

        /**
         * STYLE 12: THE TUNNEL GEOMETRY
         */
        class TunnelClock {
            constructor(ctx, width, height, palette) {
                this.name = "Tunnel Geometry";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.bg = palette.bg;
                
                let safeColors = palette.colors.filter(c => Color.getLuminance(c) > 20);
                safeColors = [...new Set(safeColors)];
                
                if (safeColors.length === 0) safeColors = ["#CCCCCC", "#999999"];
                if (safeColors.length === 1) safeColors.push(Color.getLuminance(safeColors[0]) > 200 ? "#888888" : "#FFFFFF");
                
                this.cTop = safeColors[0];
                this.cBottom = safeColors.length > 2 ? safeColors[2] : safeColors[0];
                this.cLeft = safeColors[1];
                this.cRight = safeColors.length > 3 ? safeColors[3] : safeColors[1];

                this.boxColor = "#000000";
                this.timeColor = "#E0E0E0";
                
                this.boxPos = { x: width/2, y: height/2 };
            }

            getPositions() {
                const padX = this.w * 0.25;
                const padY = this.h * 0.25;
                const cx = this.w / 2;
                const cy = this.h / 2;
                const left = padX;
                const right = this.w - padX;
                const top = padY;
                const bottom = this.h - padY;

                return [
                    { x: left, y: top },      
                    { x: cx, y: top },        
                    { x: right, y: top },     
                    { x: right, y: cy },      
                    { x: right, y: bottom },  
                    { x: cx, y: bottom },     
                    { x: left, y: bottom },   
                    { x: left, y: cy }        
                ];
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const totalSeconds = (h * 3600) + (m * 60) + s;
                const positions = this.getPositions();
                const currentIdx = totalSeconds % 8;
                const prevIdx = (totalSeconds - 1 + 8) % 8;
                const targetPos = positions[currentIdx];
                const prevPos = positions[prevIdx];

                let t = ms / 1000;
                const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                this.boxPos = {
                    x: prevPos.x + (targetPos.x - prevPos.x) * ease,
                    y: prevPos.y + (targetPos.y - prevPos.y) * ease
                };

                const boxSize = Math.min(this.w, this.h) * 0.25;
                const bx = this.boxPos.x - boxSize/2;
                const by = this.boxPos.y - boxSize/2;
                const br = bx + boxSize;
                const bb = by + boxSize;

                this.ctx.fillStyle = this.cTop;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0); this.ctx.lineTo(this.w, 0); this.ctx.lineTo(br, by); this.ctx.lineTo(bx, by);
                this.ctx.fill();

                this.ctx.fillStyle = this.cBottom;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.h); this.ctx.lineTo(this.w, this.h); this.ctx.lineTo(br, bb); this.ctx.lineTo(bx, bb);
                this.ctx.fill();

                this.ctx.fillStyle = this.cLeft;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0); this.ctx.lineTo(0, this.h); this.ctx.lineTo(bx, bb); this.ctx.lineTo(bx, by);
                this.ctx.fill();

                this.ctx.fillStyle = this.cRight;
                this.ctx.beginPath();
                this.ctx.moveTo(this.w, 0); this.ctx.lineTo(this.w, this.h); this.ctx.lineTo(br, bb); this.ctx.lineTo(br, by);
                this.ctx.fill();

                this.ctx.fillStyle = this.boxColor;
                this.ctx.fillRect(bx, by, boxSize, boxSize);

                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.fillStyle = this.timeColor;
                const fontSize = boxSize * 0.35;
                this.ctx.font = `700 ${fontSize}px 'Inter'`;
                
                const timeStr = `${h12}:${m.toString().padStart(2,'0')}`;
                const timeY = this.boxPos.y - boxSize * 0.15;
                this.ctx.fillText(timeStr, this.boxPos.x, timeY);
                const timeWidth = this.ctx.measureText(timeStr).width;
                
                const secStr = s.toString().padStart(2,'0');
                const secY = this.boxPos.y + boxSize * 0.25;
                
                this.ctx.fillStyle = this.boxColor;
                this.ctx.strokeStyle = this.cTop;
                this.ctx.lineWidth = Math.max(2, fontSize * 0.04);
                this.ctx.lineJoin = 'round';
                
                const secWidth = this.ctx.measureText(secStr).width;
                const scaleX = secWidth > 0 ? timeWidth / secWidth : 1;
                
                this.ctx.save();
                this.ctx.translate(this.boxPos.x, secY);
                this.ctx.scale(scaleX, 1);
                this.ctx.strokeText(secStr, 0, 0);
                this.ctx.fillText(secStr, 0, 0);
                this.ctx.restore();
            }
        }

        /**
         * STYLE 13: THE STAIRCASE
         */
        class StaircaseClock {
            constructor(ctx, width, height, palette) {
                this.name = "Infinite Staircase";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.bg = palette.bg;
                
                let stairColor = palette.colors[0];
                const bgLum = Color.getLuminance(this.bg);
                if (Color.getLuminance(stairColor) >= bgLum) {
                    const darker = palette.colors.find(c => Color.getLuminance(c) < bgLum);
                    stairColor = darker ? darker : "#000000";
                }
                
                this.colors = [stairColor, palette.colors[1] || palette.colors[0]];
                this.textColor = palette.text;
                this.stepH = 60;
                this.stepW = 100;
                this.ballR = 20;
                this.bounceHeight = 120;
                this.fps = 12;
            }

            roughLine(x1, y1, x2, y2) {
                const len = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
                const steps = Math.ceil(len / 10);
                const dx = (x2-x1)/steps;
                const dy = (y2-y1)/steps;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                for(let i=1; i<=steps; i++) {
                    const jitterX = Math.random() * 2 - 1;
                    const jitterY = Math.random() * 2 - 1;
                    this.ctx.lineTo(x1 + dx*i + jitterX, y1 + dy*i + jitterY);
                }
                this.ctx.stroke();
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const rawT = ms / 1000;
                const t = Math.floor(rawT * this.fps) / this.fps;
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const cx = this.w / 2;
                const cy = this.h / 2;

                this.ctx.save();
                this.ctx.fillStyle = this.textColor;
                this.ctx.textAlign = "right";
                this.ctx.textBaseline = "top";
                this.ctx.font = "400 5vw 'Abril Fatface'"; 
                this.ctx.globalAlpha = 0.8; 
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, this.w - 30, 30);
                this.ctx.font = "400 2vw 'Abril Fatface'";
                this.ctx.fillText(`${s.toString().padStart(2,'0')} ${ampm}`, this.w - 30, 30 + (this.w * 0.06));
                this.ctx.restore();

                const offsetX = -t * this.stepW;
                const offsetY = -t * this.stepH;
                const stepsNeeded = Math.ceil(Math.max(this.w, this.h) / Math.min(this.stepW, this.stepH)) + 4;
                
                this.ctx.strokeStyle = this.textColor;
                this.ctx.lineWidth = 3;
                this.ctx.fillStyle = this.colors[0]; 

                for(let i = -stepsNeeded; i <= stepsNeeded; i++) {
                    const sx = cx + (i * this.stepW) + offsetX;
                    const sy = cy + (i * this.stepH) + offsetY;
                    const xL = sx - this.stepW/2;
                    const xR = sx + this.stepW/2;
                    const ySurface = sy + this.stepH/2; 
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(xL - 1, ySurface);
                    this.ctx.lineTo(xR + 1, ySurface);
                    this.ctx.lineTo(xR + 1, this.h);
                    this.ctx.lineTo(xL - 1, this.h);
                    this.ctx.fill();

                    this.roughLine(xL, ySurface, xR, ySurface);
                    this.roughLine(xR, ySurface, xR, ySurface + this.stepH);
                }

                const bounce = 4 * t * (1 - t);
                const yPos = cy + this.stepH/2 - this.ballR - (bounce * this.bounceHeight);
                const totalDist = ((s % 60) + t) * this.stepW; 
                const rotation = totalDist / this.ballR;

                this.ctx.save();
                this.ctx.translate(cx, yPos);
                
                const velocity = Math.abs(t - 0.5); 
                const stretch = velocity * 0.2; 
                const impactSignal = Math.pow((Math.cos(t * Math.PI * 2) + 1) / 2, 20); 
                const squash = impactSignal * 0.25; 
                const sy = 1 + stretch - squash;
                const sx = 1 / sy;
                
                this.ctx.scale(sx, sy);
                this.ctx.rotate(rotation); 

                this.ctx.fillStyle = this.colors[1] || "red";
                this.ctx.strokeStyle = this.textColor; 
                this.ctx.lineJoin = 'round'; 
                this.ctx.lineWidth = 2;

                this.ctx.beginPath();
                const segments = 20;
                for(let i=0; i<=segments; i++) {
                    const ang = (i/segments) * PI2;
                    const r = this.ballR + (Math.random() * 2);
                    if(i===0) this.ctx.moveTo(Math.cos(ang)*r, Math.sin(ang)*r);
                    else this.ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
                }
                this.ctx.closePath(); 
                this.ctx.fill();
                this.ctx.stroke();

                this.ctx.restore();

                this.ctx.save();
                this.ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                const frameSeed = (s * 12345) ^ Math.floor(rawT * this.fps * 67890);
                let seed = frameSeed;
                const seededRandom = () => { seed = (seed * 9301 + 49297) % 233280; return seed / 233280; };
                const speckCount = (this.w * this.h) / 6000; 
                for(let i=0; i<speckCount; i++) {
                    const x = seededRandom() * this.w;
                    const y = seededRandom() * this.h;
                    const size = seededRandom() * 3 + 2; 
                    this.ctx.fillRect(x, y, size, size);
                }
                this.ctx.restore();
            }
        }

        /* -----------------------------------------------------------
           NEW STYLES
           ----------------------------------------------------------- */

        /**
         * STYLE 14: ISO-CITY
         */
        class IsoCityClock {
            constructor(ctx, width, height, palette) {
                this.name = "Iso-City Architecture";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                const mainColor = palette.colors[0];
                this.faceTop = mainColor;
                this.faceRight = Color.shade(mainColor, -0.2); 
                this.faceLeft = Color.shade(mainColor, -0.4); 

                this.accent = palette.colors[1] || "#FFFFFF";
            }

            toIso(x, y, z) {
                return {
                    x: (x - y) * Math.cos(Math.PI/6),
                    y: (x + y) * Math.sin(Math.PI/6) - z
                };
            }

            drawCube(cx, cy, size, h, val, maxVal) {
                const w = size;
                const z = h; 
                
                const tileW = w * Math.cos(Math.PI/6);
                const tileH = w * Math.sin(Math.PI/6);

                const topX = cx;
                const topY = cy - z;

                this.ctx.fillStyle = this.faceLeft;
                this.ctx.beginPath();
                this.ctx.moveTo(topX, topY + tileH); 
                this.ctx.lineTo(topX - tileW, topY); 
                this.ctx.lineTo(topX - tileW, topY + z); 
                this.ctx.lineTo(topX, topY + tileH + z); 
                this.ctx.fill();

                this.ctx.fillStyle = this.faceRight;
                this.ctx.beginPath();
                this.ctx.moveTo(topX, topY + tileH); 
                this.ctx.lineTo(topX + tileW, topY); 
                this.ctx.lineTo(topX + tileW, topY + z); 
                this.ctx.lineTo(topX, topY + tileH + z); 
                this.ctx.fill();

                this.ctx.fillStyle = this.faceTop;
                this.ctx.beginPath();
                this.ctx.moveTo(topX, topY - tileH);
                this.ctx.lineTo(topX + tileW, topY);
                this.ctx.lineTo(topX, topY + tileH);
                this.ctx.lineTo(topX - tileW, topY);
                this.ctx.fill();

                this.ctx.fillStyle = this.textColor; 
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = `bold ${w*0.4}px 'Inter'`;
                this.ctx.fillText(val, topX, topY);
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const cx = this.w / 2;
                const cy = this.h * 0.75; 

                const maxH = this.h * 0.5;
                const blockSize = Math.min(this.w, this.h) * 0.15;
                const spacing = blockSize * 1.5;

                const hHeight = (h % 12 + m/60) / 12 * maxH + 20;
                const mHeight = (m + s/60) / 60 * maxH + 20;
                const t = ms / 1000;
                const elastic = t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1;
                const baseS = (s / 60) * maxH;
                const sHeight = baseS + (1/60 * maxH * elastic) + 20;

                const isoSpacingX = spacing * Math.cos(Math.PI/6) * 2;
                const isoSpacingY = spacing * Math.sin(Math.PI/6) * 2;

                this.drawCube(cx - isoSpacingX, cy - isoSpacingY, blockSize, hHeight, h12, 12);

                this.drawCube(cx, cy, blockSize, mHeight, m.toString().padStart(2,'0'), 60);

                this.drawCube(cx + isoSpacingX, cy + isoSpacingY, blockSize, sHeight, s.toString().padStart(2,'0'), 60);

                this.ctx.strokeStyle = this.textColor;
                this.ctx.globalAlpha = 0.1;
                this.ctx.lineWidth = 2;
                
                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy); 
                this.ctx.lineTo(cx - 500, cy - 250);
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx + 500, cy - 250);
                this.ctx.moveTo(cx, cy);
                this.ctx.lineTo(cx, cy + 500);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1.0;
                
                this.ctx.textAlign = "right";
                this.ctx.font = "20px 'Space Mono'";
                this.ctx.fillStyle = this.textColor;
                this.ctx.fillText(ampm, this.w - 30, 40);
            }
        }

        /**
         * STYLE 15: THE RADIAL TURBINE
         */
        class TurbineClock {
            constructor(ctx, width, height, palette) {
                this.name = "Radial Turbine";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.bg = palette.bg;
                this.textColor = palette.text;
                this.colors = palette.colors;
                
                this.cPrimary = this.colors[0];
                this.cSecondary = this.colors[1] || this.colors[0];
                this.cHigh = this.colors[2] || "#FFFFFF";
            }

            drawSegmentedRing(cx, cy, radius, width, segments, filledCount, color, rotation) {
                const step = (Math.PI * 2) / segments;
                const pad = 0.05; 
                
                this.ctx.save();
                this.ctx.translate(cx, cy);
                this.ctx.rotate(rotation);
                
                this.ctx.fillStyle = color;
                
                for(let i=0; i<segments; i++) {
                    this.ctx.globalAlpha = i < filledCount ? 1.0 : 0.1;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius + width/2, i*step + pad, (i+1)*step - pad);
                    this.ctx.arc(0, 0, radius - width/2, (i+1)*step - pad, i*step + pad, true);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                const cx = this.w / 2;
                const cy = this.h / 2;
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);

                const minDim = Math.min(this.w, this.h);
                
                const sRot = smoothS * 0.1; 
                this.drawSegmentedRing(cx, cy, minDim * 0.4, minDim * 0.05, 60, s, this.cHigh, -sRot);

                const mRot = (m + s/60) * 0.05;
                this.drawSegmentedRing(cx, cy, minDim * 0.3, minDim * 0.08, 60, m, this.cPrimary, mRot);

                const hVal = h % 12 || 12;
                const hRot = (h % 12) * 0.01;
                this.drawSegmentedRing(cx, cy, minDim * 0.18, minDim * 0.10, 12, hVal, this.cSecondary, hRot);

                this.ctx.fillStyle = this.textColor;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, minDim * 0.1, 0, PI2);
                this.ctx.fill();
                
                this.ctx.fillStyle = this.bg;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = `bold ${minDim * 0.05}px 'Space Mono'`;
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, cx, cy);
                
                this.ctx.font = `bold ${minDim * 0.02}px 'Space Mono'`;
                this.ctx.fillText(ampm, cx, cy + minDim * 0.04);

                this.ctx.strokeStyle = this.textColor;
                this.ctx.globalAlpha = 0.2;
                this.ctx.lineWidth = 1;
                
                this.ctx.beginPath();
                this.ctx.moveTo(cx - minDim*0.5, cy); this.ctx.lineTo(cx + minDim*0.5, cy);
                this.ctx.moveTo(cx, cy - minDim*0.5); this.ctx.lineTo(cx, cy + minDim*0.5);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                const pulse = Math.sin(smoothS * 10) * 5;
                this.ctx.arc(cx, cy, minDim * 0.45 + pulse, 0, PI2);
                this.ctx.stroke();
                
                this.ctx.globalAlpha = 1.0;
            }
        }

        /**
         * STYLE 16: TOPOGRAPHIC MAP
         * Organic, shifting contour lines simulating terrain.
         */
        class TopographicClock {
            constructor(ctx, width, height, palette) {
                this.name = "Topographic Map";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.colors = palette.colors;
                this.bg = palette.bg;
                this.textColor = palette.text;
                
                // Noise offset cache
                this.noiseOffsets = [];
                for(let i=0; i<10; i++) {
                    this.noiseOffsets.push(Math.random() * 100);
                }
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                const cx = this.w / 2;
                const cy = this.h / 2;
                const maxR = Math.min(this.w, this.h) * 0.45;
                
                // Draw 5 major contour layers
                const layers = 6;
                for(let i=layers; i>0; i--) {
                    this.ctx.fillStyle = this.colors[(i-1) % this.colors.length];
                    this.ctx.beginPath();
                    
                    const baseR = (maxR / layers) * i;
                    const points = 60; // Resolution
                    
                    for(let j=0; j<=points; j++) {
                        const angle = (j / points) * PI2;
                        
                        // Create wobbly noise effect using sines
                        // Each layer has different frequencies
                        const noise = Math.sin(angle * (3 + i) + smoothS * 0.2 + this.noiseOffsets[i]) * 20 +
                                      Math.cos(angle * (5 - i) - smoothS * 0.1) * 10;
                        
                        const r = baseR + noise;
                        const x = cx + Math.cos(angle) * r;
                        const y = cy + Math.sin(angle) * r;
                        
                        if(j===0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Stroke for map look
                    this.ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                // Time as altitude markers
                this.ctx.fillStyle = this.textColor; //Color.getContrastColor(this.colors[0]);
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = "700 40px 'Space Mono'";
                
                // Add a "Shadow" to text for readability on colors
                this.ctx.shadowColor = "rgba(0,0,0,0.5)";
                this.ctx.shadowBlur = 10;
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, cx, cy);
                this.ctx.shadowBlur = 0;
                
                this.ctx.font = "14px 'Space Mono'";
                this.ctx.fillText(`ELEV. ${s * 10}'`, cx, cy + 40);
            }
        }

        /**
         * STYLE 17: VECTOR SCOPE
         * Glowing green lines, jittery analog aesthetic.
         */
        class VectorScopeClock {
            constructor(ctx, width, height, palette) {
                this.name = "Vector Scope";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.bg = "#001100"; // Deep dark green/black
                this.scopeColor = "#00FF44"; // Phosphor Green
                this.gridColor = "#003311";
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                // CRT Fade effect
                this.ctx.fillStyle = "rgba(0, 15, 0, 0.2)";
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                const cx = this.w / 2;
                const cy = this.h / 2;
                
                // 1. Grid
                this.ctx.strokeStyle = this.gridColor;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                // Draw a few grid lines
                for(let x=0; x<this.w; x+=50) { this.ctx.moveTo(x,0); this.ctx.lineTo(x, this.h); }
                for(let y=0; y<this.h; y+=50) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.w, y); }
                this.ctx.stroke();

                // 2. Lissajous / Scope Waves
                this.ctx.strokeStyle = this.scopeColor;
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = this.scopeColor;
                
                this.ctx.beginPath();
                // Draw a wave representing seconds
                for(let x=0; x<this.w; x+=5) {
                    const y = cy + Math.sin(x * 0.02 + smoothS * 5) * 50 * Math.sin(smoothS);
                    // Add noise jitter
                    const jitter = (Math.random() - 0.5) * 5;
                    if(x===0) this.ctx.moveTo(x, y+jitter);
                    else this.ctx.lineTo(x, y+jitter);
                }
                this.ctx.stroke();
                
                // 3. Vector Text
                this.ctx.fillStyle = this.scopeColor;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = "80px 'Space Mono'"; // Monospaced fits the vibe
                
                // Jitter the text position slightly
                const tx = cx + (Math.random() - 0.5) * 2;
                const ty = cy + (Math.random() - 0.5) * 2;
                
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, tx, ty);
                
                this.ctx.font = "20px 'Space Mono'";
                this.ctx.fillText(`CH-A: ${ampm} // CH-B: ${s}Hz`, tx, ty + 60);
                
                this.ctx.shadowBlur = 0;
            }
        }

        /**
         * STYLE 18: HYPNO-RINGS
         * Modernist concentric rings creating interference patterns.
         */
        class HypnoRingsClock {
            constructor(ctx, width, height, palette) {
                this.name = "Hypno-Rings";
                this.ctx = ctx;
                this.w = width;
                this.h = height;
                this.bg = palette.bg;
                this.colors = palette.colors;
                this.textColor = palette.text;
            }

            draw(time) {
                const { h, m, s, ms, h12, ampm } = time;
                const smoothS = s + (ms/1000);
                
                this.ctx.fillStyle = this.bg;
                this.ctx.fillRect(0, 0, this.w, this.h);
                
                const cx = this.w / 2;
                const cy = this.h / 2;
                const maxR = Math.min(this.w, this.h) * 0.45;
                const ringCount = 12;
                const ringW = maxR / ringCount;
                
                this.ctx.lineWidth = ringW * 0.8;
                this.ctx.lineCap = "butt";
                
                for(let i=0; i<ringCount; i++) {
                    const r = (i+1) * ringW;
                    const color = this.colors[i % this.colors.length];
                    this.ctx.strokeStyle = color;
                    
                    // Calculate speed - alternate directions
                    const dir = i % 2 === 0 ? 1 : -1;
                    const speed = (ringCount - i) * 0.1; // Outer rings slower? or inner?
                    const rotation = smoothS * speed * dir;
                    
                    this.ctx.beginPath();
                    // Draw dashed ring
                    const dashLen = (Math.PI * r) / (i + 2); // Varying segment counts
                    this.ctx.setLineDash([dashLen, dashLen * 0.5]);
                    this.ctx.lineDashOffset = rotation * r; // Animate dash offset
                    
                    this.ctx.arc(cx, cy, r, 0, PI2);
                    this.ctx.stroke();
                }
                
                // Reset dash
                this.ctx.setLineDash([]);
                
                // Center Time Bubble
                this.ctx.fillStyle = this.bg;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, ringW * 2.5, 0, PI2);
                this.ctx.fill();
                
                this.ctx.fillStyle = this.textColor;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = "bold 40px 'Syne'";
                this.ctx.fillText(`${h12}:${m.toString().padStart(2,'0')}`, cx, cy);
            }
        }


        // --- ENGINE ---

        class App {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.modal = document.getElementById('modal-overlay');
                this.uiModel = document.getElementById('m-model');
                this.uiPalette = document.getElementById('m-palette');
                
                // Define strategies list
                this.strategies = [
                    TunnelClock,      // User Fav
                    StaircaseClock,   // User Fav
                    TopographicClock, // NEW
                    VectorScopeClock, // NEW
                    HypnoRingsClock,  // NEW
                    IsoCityClock,     
                    TurbineClock,     
                    ConstructivistClock,
                    KineticClock, 
                    CelestialClock, 
                    DeStijlClock,
                    SlitScanClock, 
                    SwarmClock,    
                    EchoClock,
                    VitruvianClock, 
                    RomanDialClock,
                    AuroraClock, 
                    FrequencyClock
                ];

                // Initialize random index
                this.clockIndex = Random.int(0, this.strategies.length - 1) - 1;
                if(this.clockIndex < 0) this.clockIndex = this.strategies.length - 1;

                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Keyboard Listeners
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key === 'r') this.regenerate();
                    if (key === 'c') this.regeneratePalette();
                    if (key === 'escape') this.closeModal();
                });

                this.regenerate();
                this.loop();
            }

            resize() {
                this.w = window.innerWidth;
                this.h = window.innerHeight;
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.w * dpr;
                this.canvas.height = this.h * dpr;
                this.ctx.scale(dpr, dpr);
                
                if(this.renderer) {
                    const RendererClass = this.renderer.constructor;
                    this.renderer = new RendererClass(this.ctx, this.w, this.h, this.currentPalette);
                }
            }

            toggleModal() {
                this.modal.classList.toggle('active');
            }

            closeModal() {
                this.modal.classList.remove('active');
            }

            _setupPalette() {
                const rawPalette = Random.pick(PALETTES);
                this.currentPalette = { ...rawPalette, colors: [...rawPalette.colors] };
                this.currentPalette.text = Color.getContrastColor(this.currentPalette.bg);
                this.currentPalette.colors.sort((a, b) => {
                    const diffA = Color.getContrastDiff(a, this.currentPalette.bg);
                    const diffB = Color.getContrastDiff(b, this.currentPalette.bg);
                    return diffB - diffA; 
                });
                document.documentElement.style.setProperty('--bg-color', this.currentPalette.bg);
            }

            regenerate() {
                this._setupPalette();
                this.clockIndex = (this.clockIndex + 1) % this.strategies.length;
                const Strategy = this.strategies[this.clockIndex];
                this.renderer = new Strategy(this.ctx, this.w, this.h, this.currentPalette);
                this.updateUI();
            }

            regeneratePalette() {
                if(!this.renderer) return;
                this._setupPalette();
                const Strategy = this.renderer.constructor;
                this.renderer = new Strategy(this.ctx, this.w, this.h, this.currentPalette);
                this.updateUI();
            }

            updateUI() {
                this.uiModel.innerText = this.renderer.name;
                this.uiPalette.innerText = this.currentPalette.name;
            }

            loop() {
                const now = new Date();
                const rawH = now.getHours();
                const time = {
                    h: rawH,
                    h12: rawH % 12 || 12,
                    ampm: rawH >= 12 ? 'PM' : 'AM',
                    m: now.getMinutes(),
                    s: now.getSeconds(),
                    ms: now.getMilliseconds()
                };

                if (this.renderer) {
                    this.renderer.draw(time);
                }

                requestAnimationFrame(() => this.loop());
            }
        }

        // Start
        const app = new App();

    </script>
</body>
</html>
